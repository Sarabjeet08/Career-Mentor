////  StudyViewController.swift//  CareerMentor////  Created by user275188 on 4/9/25.//import UIKitimport FirebaseAuthimport FirebaseFirestoreclass StudyViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {        @IBOutlet weak var questionTableView: UITableView!    @IBOutlet weak var scoreLabel: UILabel!    @IBOutlet weak var usernameLabel: UILabel!    @IBOutlet weak var highestScoreLabel: UILabel!    @IBOutlet weak var questionNumberLabel: UILabel!        var questions: [MCQQuestion] = []    var currentQuestionIndex = 0    var score = 0    var selectedDifficulty: String?    var selectedAnswerIndex: Int? // Track selected answer index for highlighting    var answerSelected = false  // Track if user has selected an answer        override func viewDidLoad() {        super.viewDidLoad()        loadUserData()        questionTableView.delegate = self        questionTableView.dataSource = self                // Set automatic dimension for row height based on content        questionTableView.rowHeight = UITableView.automaticDimension        questionTableView.estimatedRowHeight = 100                // Fetch questions based on selected difficulty        fetchQuestions()    }        func fetchQuestions() {        MCQService.shared.fetchProgrammingQuestions(difficulty: selectedDifficulty) { [weak self] questions in            if let questions = questions {                self?.questions = questions                DispatchQueue.main.async {                    self?.questionTableView.reloadData()                    self?.updateQuestionNumberLabel() // Update question number                }            }        }    }        func loadUserData() {        if let user = Auth.auth().currentUser {            let db = Firestore.firestore()                        // Fetch username and highest score from Firestore            db.collection("users").document(user.uid).getDocument { document, error in                if let error = error {                    print("Error fetching user data: \(error.localizedDescription)")                    return                }                                if let document = document, document.exists,                   let userData = document.data() {                    let username = userData["username"] as? String ?? "Guest"                    let highestScore = userData["high_score"] as? Int ?? 0                                        // Update the UI with username and highest score                    self.usernameLabel.text = "Hello, \(username)"                    self.highestScoreLabel.text = "Highest Score: \(highestScore)"                }            }        }    }        func updateUserScore(newScore: Int) {        if let user = Auth.auth().currentUser {            let db = Firestore.firestore()            let userRef = db.collection("users").document(user.uid)                        // Get the current highest score from Firestore            userRef.getDocument { document, error in                if let error = error {                    print("Error fetching user data: \(error.localizedDescription)")                    return                }                                if let document = document, document.exists {                    var highestScore = document["high_score"] as? Int ?? 0                                        // If the new score is higher than the current highest score, update it                    if newScore > highestScore {                        highestScore = newScore                        // Update the highest score in Firestore                        userRef.updateData(["high_score": highestScore]) { error in                            if let error = error {                                print("Error updating highest score: \(error.localizedDescription)")                            } else {                                print("Highest score updated successfully!")                            }                        }                    }                }            }        }    }        // UITableView DataSource Methods    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {        guard !questions.isEmpty else {            return 0  // Return 0 rows if questions are empty        }                return 1 + questions[currentQuestionIndex].decodedOptions.count    }        // Configure each cell based on its index path    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {        if indexPath.row == 0 {            // Return the question cell            let cell = tableView.dequeueReusableCell(withIdentifier: "QuestionCell", for: indexPath)            let question = questions[currentQuestionIndex]            if let questionLabel = cell.textLabel {                questionLabel.numberOfLines = 0  // Allow multiple lines                questionLabel.lineBreakMode = .byWordWrapping                questionLabel.text = question.decodedQuestion // Decode HTML            }            cell.selectionStyle = .none // Disable selection for question cell            return cell        } else {            // Return the answer option cell            let cell = tableView.dequeueReusableCell(withIdentifier: "AnswerCell", for: indexPath)            let question = questions[currentQuestionIndex]            let optionIndex = indexPath.row - 1  // Adjust for the question cell                        guard optionIndex < question.decodedOptions.count else {                return UITableViewCell() // Return empty cell if the index is out of bounds            }            // Allow multiple lines for options         if let optionLabel = cell.textLabel {                optionLabel.numberOfLines = 0  // Allow multiple lines for answer options                optionLabel.lineBreakMode = .byWordWrapping                       }            cell.textLabel?.text = question.decodedOptions[optionIndex] // Decode HTML for option            cell.textLabel?.textColor = .black // Reset text color            // Highlight selected answer after selection            if answerSelected {                if optionIndex == selectedAnswerIndex {                    if question.decodedOptions[optionIndex] == question.decodedCorrectAnswer {                        cell.textLabel?.textColor = .green // Correct answer                    } else {                        cell.textLabel?.textColor = .red // Wrong answer                    }                }            }                        return cell        }    }        // Handle Answer Selection    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        guard indexPath.row != 0 else { return }  // Don't allow selection on the question cell                let optionIndex = indexPath.row - 1  // Adjust for question cell        guard optionIndex < questions[currentQuestionIndex].decodedOptions.count else {            return  // Prevent out-of-bounds error when selecting an invalid option        }                if answerSelected { return }  // Prevent multiple selections for the same question                selectedAnswerIndex = optionIndex // Track the selected answer        answerSelected = true                let selectedAnswer = questions[currentQuestionIndex].decodedOptions[optionIndex]        if selectedAnswer == questions[currentQuestionIndex].decodedCorrectAnswer {            score += 1        }                // Reload table to reflect the changes (color change, etc.)        tableView.reloadData()                // Add delay before moving to the next question        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {             self.moveToNextQuestion()        }    }        // Move to next question    func moveToNextQuestion() {        currentQuestionIndex += 1        if currentQuestionIndex < questions.count {            // Reset the state for next question            answerSelected = false            selectedAnswerIndex = nil            questionTableView.reloadData()            updateQuestionNumberLabel() // Update question number        } else {            showScore() // End quiz if there are no more questions        }    }        func updateQuestionNumberLabel() {        let currentQuestionNumber = currentQuestionIndex + 1        questionNumberLabel.text = "Question \(currentQuestionNumber) out of \(questions.count)"    }        func showScore() {        scoreLabel.text = "Your score: \(score) / \(questions.count)"        updateUserScore(newScore: score)                // Show alert for the final score        let alert = UIAlertController(            title: "Quiz Completed",            message: "Your score: \(score) / \(questions.count)",            preferredStyle: .alert        )        alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in            self.navigationController?.popViewController(animated: true)        })        present(alert, animated: true)    }}